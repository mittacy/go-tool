// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package sliceUtil

// DiffString 求差集
// @param array
// @param arrays
// @return []String 出现在第一个数组中但其他输入数组中没有的值，顺序为第一个数组的原顺序
func DiffString(array []string, arrays ...[]string) []string {
	m := ToMapStringStruct(arrays...)

	res := make([]string, 0)
	for _, v := range array {
		if _, ok := m[v]; !ok {
			res = append(res, v)
		}
	}

	return res
}

// IntersectString 求交集
// @param array
// @param arrays
// @return []String 第一个数组中出现的且在其他每个输入数组中都出现的值，顺序为第一个数组的原顺序
func IntersectString(array []string, arrays ...[]string) []string {
	m := ToMapStringStruct(arrays...)

	res := make([]string, 0, len(array))
	for _, v := range array {
		if _, ok := m[v]; ok {
			res = append(res, v)
		}
	}

	return res
}

// TwoDiffString 比较两个数组的差异元素
// @param a a数组
// @param b b数组
// @return inAnoB 在a不在b的元素
// @return inBnoA 在b不在a的元素
func TwoDiffString(a []string, b []string) (inAnoB []string, inBnoA []string) {
	aMap := ToMapStringStruct(a)
	bMap := ToMapStringStruct(b)

	inBnoA = []string{}
	for _, v := range b {
		if _, ok := aMap[v]; !ok {
			inBnoA = append(inBnoA, v)
		}
	}

	inAnoB = []string{}
	for _, v := range a {
		if _, ok := bMap[v]; !ok {
			inAnoB = append(inAnoB, v)
		}
	}

	return inAnoB, inBnoA
}

// DiffRune 求差集
// @param array
// @param arrays
// @return []Rune 出现在第一个数组中但其他输入数组中没有的值，顺序为第一个数组的原顺序
func DiffRune(array []rune, arrays ...[]rune) []rune {
	m := ToMapRuneStruct(arrays...)

	res := make([]rune, 0)
	for _, v := range array {
		if _, ok := m[v]; !ok {
			res = append(res, v)
		}
	}

	return res
}

// IntersectRune 求交集
// @param array
// @param arrays
// @return []Rune 第一个数组中出现的且在其他每个输入数组中都出现的值，顺序为第一个数组的原顺序
func IntersectRune(array []rune, arrays ...[]rune) []rune {
	m := ToMapRuneStruct(arrays...)

	res := make([]rune, 0, len(array))
	for _, v := range array {
		if _, ok := m[v]; ok {
			res = append(res, v)
		}
	}

	return res
}

// TwoDiffRune 比较两个数组的差异元素
// @param a a数组
// @param b b数组
// @return inAnoB 在a不在b的元素
// @return inBnoA 在b不在a的元素
func TwoDiffRune(a []rune, b []rune) (inAnoB []rune, inBnoA []rune) {
	aMap := ToMapRuneStruct(a)
	bMap := ToMapRuneStruct(b)

	inBnoA = []rune{}
	for _, v := range b {
		if _, ok := aMap[v]; !ok {
			inBnoA = append(inBnoA, v)
		}
	}

	inAnoB = []rune{}
	for _, v := range a {
		if _, ok := bMap[v]; !ok {
			inAnoB = append(inAnoB, v)
		}
	}

	return inAnoB, inBnoA
}

// DiffInt8 求差集
// @param array
// @param arrays
// @return []Int8 出现在第一个数组中但其他输入数组中没有的值，顺序为第一个数组的原顺序
func DiffInt8(array []int8, arrays ...[]int8) []int8 {
	m := ToMapInt8Struct(arrays...)

	res := make([]int8, 0)
	for _, v := range array {
		if _, ok := m[v]; !ok {
			res = append(res, v)
		}
	}

	return res
}

// IntersectInt8 求交集
// @param array
// @param arrays
// @return []Int8 第一个数组中出现的且在其他每个输入数组中都出现的值，顺序为第一个数组的原顺序
func IntersectInt8(array []int8, arrays ...[]int8) []int8 {
	m := ToMapInt8Struct(arrays...)

	res := make([]int8, 0, len(array))
	for _, v := range array {
		if _, ok := m[v]; ok {
			res = append(res, v)
		}
	}

	return res
}

// TwoDiffInt8 比较两个数组的差异元素
// @param a a数组
// @param b b数组
// @return inAnoB 在a不在b的元素
// @return inBnoA 在b不在a的元素
func TwoDiffInt8(a []int8, b []int8) (inAnoB []int8, inBnoA []int8) {
	aMap := ToMapInt8Struct(a)
	bMap := ToMapInt8Struct(b)

	inBnoA = []int8{}
	for _, v := range b {
		if _, ok := aMap[v]; !ok {
			inBnoA = append(inBnoA, v)
		}
	}

	inAnoB = []int8{}
	for _, v := range a {
		if _, ok := bMap[v]; !ok {
			inAnoB = append(inAnoB, v)
		}
	}

	return inAnoB, inBnoA
}

// DiffInt16 求差集
// @param array
// @param arrays
// @return []Int16 出现在第一个数组中但其他输入数组中没有的值，顺序为第一个数组的原顺序
func DiffInt16(array []int16, arrays ...[]int16) []int16 {
	m := ToMapInt16Struct(arrays...)

	res := make([]int16, 0)
	for _, v := range array {
		if _, ok := m[v]; !ok {
			res = append(res, v)
		}
	}

	return res
}

// IntersectInt16 求交集
// @param array
// @param arrays
// @return []Int16 第一个数组中出现的且在其他每个输入数组中都出现的值，顺序为第一个数组的原顺序
func IntersectInt16(array []int16, arrays ...[]int16) []int16 {
	m := ToMapInt16Struct(arrays...)

	res := make([]int16, 0, len(array))
	for _, v := range array {
		if _, ok := m[v]; ok {
			res = append(res, v)
		}
	}

	return res
}

// TwoDiffInt16 比较两个数组的差异元素
// @param a a数组
// @param b b数组
// @return inAnoB 在a不在b的元素
// @return inBnoA 在b不在a的元素
func TwoDiffInt16(a []int16, b []int16) (inAnoB []int16, inBnoA []int16) {
	aMap := ToMapInt16Struct(a)
	bMap := ToMapInt16Struct(b)

	inBnoA = []int16{}
	for _, v := range b {
		if _, ok := aMap[v]; !ok {
			inBnoA = append(inBnoA, v)
		}
	}

	inAnoB = []int16{}
	for _, v := range a {
		if _, ok := bMap[v]; !ok {
			inAnoB = append(inAnoB, v)
		}
	}

	return inAnoB, inBnoA
}

// DiffInt 求差集
// @param array
// @param arrays
// @return []Int 出现在第一个数组中但其他输入数组中没有的值，顺序为第一个数组的原顺序
func DiffInt(array []int, arrays ...[]int) []int {
	m := ToMapIntStruct(arrays...)

	res := make([]int, 0)
	for _, v := range array {
		if _, ok := m[v]; !ok {
			res = append(res, v)
		}
	}

	return res
}

// IntersectInt 求交集
// @param array
// @param arrays
// @return []Int 第一个数组中出现的且在其他每个输入数组中都出现的值，顺序为第一个数组的原顺序
func IntersectInt(array []int, arrays ...[]int) []int {
	m := ToMapIntStruct(arrays...)

	res := make([]int, 0, len(array))
	for _, v := range array {
		if _, ok := m[v]; ok {
			res = append(res, v)
		}
	}

	return res
}

// TwoDiffInt 比较两个数组的差异元素
// @param a a数组
// @param b b数组
// @return inAnoB 在a不在b的元素
// @return inBnoA 在b不在a的元素
func TwoDiffInt(a []int, b []int) (inAnoB []int, inBnoA []int) {
	aMap := ToMapIntStruct(a)
	bMap := ToMapIntStruct(b)

	inBnoA = []int{}
	for _, v := range b {
		if _, ok := aMap[v]; !ok {
			inBnoA = append(inBnoA, v)
		}
	}

	inAnoB = []int{}
	for _, v := range a {
		if _, ok := bMap[v]; !ok {
			inAnoB = append(inAnoB, v)
		}
	}

	return inAnoB, inBnoA
}

// DiffInt32 求差集
// @param array
// @param arrays
// @return []Int32 出现在第一个数组中但其他输入数组中没有的值，顺序为第一个数组的原顺序
func DiffInt32(array []int32, arrays ...[]int32) []int32 {
	m := ToMapInt32Struct(arrays...)

	res := make([]int32, 0)
	for _, v := range array {
		if _, ok := m[v]; !ok {
			res = append(res, v)
		}
	}

	return res
}

// IntersectInt32 求交集
// @param array
// @param arrays
// @return []Int32 第一个数组中出现的且在其他每个输入数组中都出现的值，顺序为第一个数组的原顺序
func IntersectInt32(array []int32, arrays ...[]int32) []int32 {
	m := ToMapInt32Struct(arrays...)

	res := make([]int32, 0, len(array))
	for _, v := range array {
		if _, ok := m[v]; ok {
			res = append(res, v)
		}
	}

	return res
}

// TwoDiffInt32 比较两个数组的差异元素
// @param a a数组
// @param b b数组
// @return inAnoB 在a不在b的元素
// @return inBnoA 在b不在a的元素
func TwoDiffInt32(a []int32, b []int32) (inAnoB []int32, inBnoA []int32) {
	aMap := ToMapInt32Struct(a)
	bMap := ToMapInt32Struct(b)

	inBnoA = []int32{}
	for _, v := range b {
		if _, ok := aMap[v]; !ok {
			inBnoA = append(inBnoA, v)
		}
	}

	inAnoB = []int32{}
	for _, v := range a {
		if _, ok := bMap[v]; !ok {
			inAnoB = append(inAnoB, v)
		}
	}

	return inAnoB, inBnoA
}

// DiffInt64 求差集
// @param array
// @param arrays
// @return []Int64 出现在第一个数组中但其他输入数组中没有的值，顺序为第一个数组的原顺序
func DiffInt64(array []int64, arrays ...[]int64) []int64 {
	m := ToMapInt64Struct(arrays...)

	res := make([]int64, 0)
	for _, v := range array {
		if _, ok := m[v]; !ok {
			res = append(res, v)
		}
	}

	return res
}

// IntersectInt64 求交集
// @param array
// @param arrays
// @return []Int64 第一个数组中出现的且在其他每个输入数组中都出现的值，顺序为第一个数组的原顺序
func IntersectInt64(array []int64, arrays ...[]int64) []int64 {
	m := ToMapInt64Struct(arrays...)

	res := make([]int64, 0, len(array))
	for _, v := range array {
		if _, ok := m[v]; ok {
			res = append(res, v)
		}
	}

	return res
}

// TwoDiffInt64 比较两个数组的差异元素
// @param a a数组
// @param b b数组
// @return inAnoB 在a不在b的元素
// @return inBnoA 在b不在a的元素
func TwoDiffInt64(a []int64, b []int64) (inAnoB []int64, inBnoA []int64) {
	aMap := ToMapInt64Struct(a)
	bMap := ToMapInt64Struct(b)

	inBnoA = []int64{}
	for _, v := range b {
		if _, ok := aMap[v]; !ok {
			inBnoA = append(inBnoA, v)
		}
	}

	inAnoB = []int64{}
	for _, v := range a {
		if _, ok := bMap[v]; !ok {
			inAnoB = append(inAnoB, v)
		}
	}

	return inAnoB, inBnoA
}

// DiffFloat32 求差集
// @param array
// @param arrays
// @return []Float32 出现在第一个数组中但其他输入数组中没有的值，顺序为第一个数组的原顺序
func DiffFloat32(array []float32, arrays ...[]float32) []float32 {
	m := ToMapFloat32Struct(arrays...)

	res := make([]float32, 0)
	for _, v := range array {
		if _, ok := m[v]; !ok {
			res = append(res, v)
		}
	}

	return res
}

// IntersectFloat32 求交集
// @param array
// @param arrays
// @return []Float32 第一个数组中出现的且在其他每个输入数组中都出现的值，顺序为第一个数组的原顺序
func IntersectFloat32(array []float32, arrays ...[]float32) []float32 {
	m := ToMapFloat32Struct(arrays...)

	res := make([]float32, 0, len(array))
	for _, v := range array {
		if _, ok := m[v]; ok {
			res = append(res, v)
		}
	}

	return res
}

// TwoDiffFloat32 比较两个数组的差异元素
// @param a a数组
// @param b b数组
// @return inAnoB 在a不在b的元素
// @return inBnoA 在b不在a的元素
func TwoDiffFloat32(a []float32, b []float32) (inAnoB []float32, inBnoA []float32) {
	aMap := ToMapFloat32Struct(a)
	bMap := ToMapFloat32Struct(b)

	inBnoA = []float32{}
	for _, v := range b {
		if _, ok := aMap[v]; !ok {
			inBnoA = append(inBnoA, v)
		}
	}

	inAnoB = []float32{}
	for _, v := range a {
		if _, ok := bMap[v]; !ok {
			inAnoB = append(inAnoB, v)
		}
	}

	return inAnoB, inBnoA
}

// DiffFloat64 求差集
// @param array
// @param arrays
// @return []Float64 出现在第一个数组中但其他输入数组中没有的值，顺序为第一个数组的原顺序
func DiffFloat64(array []float64, arrays ...[]float64) []float64 {
	m := ToMapFloat64Struct(arrays...)

	res := make([]float64, 0)
	for _, v := range array {
		if _, ok := m[v]; !ok {
			res = append(res, v)
		}
	}

	return res
}

// IntersectFloat64 求交集
// @param array
// @param arrays
// @return []Float64 第一个数组中出现的且在其他每个输入数组中都出现的值，顺序为第一个数组的原顺序
func IntersectFloat64(array []float64, arrays ...[]float64) []float64 {
	m := ToMapFloat64Struct(arrays...)

	res := make([]float64, 0, len(array))
	for _, v := range array {
		if _, ok := m[v]; ok {
			res = append(res, v)
		}
	}

	return res
}

// TwoDiffFloat64 比较两个数组的差异元素
// @param a a数组
// @param b b数组
// @return inAnoB 在a不在b的元素
// @return inBnoA 在b不在a的元素
func TwoDiffFloat64(a []float64, b []float64) (inAnoB []float64, inBnoA []float64) {
	aMap := ToMapFloat64Struct(a)
	bMap := ToMapFloat64Struct(b)

	inBnoA = []float64{}
	for _, v := range b {
		if _, ok := aMap[v]; !ok {
			inBnoA = append(inBnoA, v)
		}
	}

	inAnoB = []float64{}
	for _, v := range a {
		if _, ok := bMap[v]; !ok {
			inAnoB = append(inAnoB, v)
		}
	}

	return inAnoB, inBnoA
}
