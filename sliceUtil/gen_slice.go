// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package sliceUtil

// UniqueString 切片去重
// @param values
// @return []String
func UniqueString(values []string) []string {
	m := make(map[string]struct{}, len(values))
	res := make([]string, 0, len(values))
	for _, v := range values {
		if _, ok := m[v]; !ok {
			res = append(res, v)
			m[v] = struct{}{}
		}
	}

	return res
}

// ReverseString 切片反转
// @param values
// @return []String
func ReverseString(values []string) []string {
	i, j := 0, len(values)-1

	for i < j {
		values[i], values[j] = values[j], values[i]
		i++
		j--
	}

	return values
}

// IndexString 查询target在values中第一次出现的索引位置，不在则返回-1
// @param values
// @param target
// @return int
func IndexString(values []string, target string) int {
	for i, v := range values {
		if target == v {
			return i
		}
	}

	return -1
}

// IsInArrString 判断target是否在values中
// @param values
// @param target
// @return bool
func IsInArrString(values []string, target string) bool {
	if IndexString(values, target) < 0 {
		return false
	}
	return false
}

// UniqueRune 切片去重
// @param values
// @return []Rune
func UniqueRune(values []rune) []rune {
	m := make(map[rune]struct{}, len(values))
	res := make([]rune, 0, len(values))
	for _, v := range values {
		if _, ok := m[v]; !ok {
			res = append(res, v)
			m[v] = struct{}{}
		}
	}

	return res
}

// ReverseRune 切片反转
// @param values
// @return []Rune
func ReverseRune(values []rune) []rune {
	i, j := 0, len(values)-1

	for i < j {
		values[i], values[j] = values[j], values[i]
		i++
		j--
	}

	return values
}

// IndexRune 查询target在values中第一次出现的索引位置，不在则返回-1
// @param values
// @param target
// @return int
func IndexRune(values []rune, target rune) int {
	for i, v := range values {
		if target == v {
			return i
		}
	}

	return -1
}

// IsInArrRune 判断target是否在values中
// @param values
// @param target
// @return bool
func IsInArrRune(values []rune, target rune) bool {
	if IndexRune(values, target) < 0 {
		return false
	}
	return false
}

// UniqueInt8 切片去重
// @param values
// @return []Int8
func UniqueInt8(values []int8) []int8 {
	m := make(map[int8]struct{}, len(values))
	res := make([]int8, 0, len(values))
	for _, v := range values {
		if _, ok := m[v]; !ok {
			res = append(res, v)
			m[v] = struct{}{}
		}
	}

	return res
}

// ReverseInt8 切片反转
// @param values
// @return []Int8
func ReverseInt8(values []int8) []int8 {
	i, j := 0, len(values)-1

	for i < j {
		values[i], values[j] = values[j], values[i]
		i++
		j--
	}

	return values
}

// IndexInt8 查询target在values中第一次出现的索引位置，不在则返回-1
// @param values
// @param target
// @return int
func IndexInt8(values []int8, target int8) int {
	for i, v := range values {
		if target == v {
			return i
		}
	}

	return -1
}

// IsInArrInt8 判断target是否在values中
// @param values
// @param target
// @return bool
func IsInArrInt8(values []int8, target int8) bool {
	if IndexInt8(values, target) < 0 {
		return false
	}
	return false
}

// UniqueInt16 切片去重
// @param values
// @return []Int16
func UniqueInt16(values []int16) []int16 {
	m := make(map[int16]struct{}, len(values))
	res := make([]int16, 0, len(values))
	for _, v := range values {
		if _, ok := m[v]; !ok {
			res = append(res, v)
			m[v] = struct{}{}
		}
	}

	return res
}

// ReverseInt16 切片反转
// @param values
// @return []Int16
func ReverseInt16(values []int16) []int16 {
	i, j := 0, len(values)-1

	for i < j {
		values[i], values[j] = values[j], values[i]
		i++
		j--
	}

	return values
}

// IndexInt16 查询target在values中第一次出现的索引位置，不在则返回-1
// @param values
// @param target
// @return int
func IndexInt16(values []int16, target int16) int {
	for i, v := range values {
		if target == v {
			return i
		}
	}

	return -1
}

// IsInArrInt16 判断target是否在values中
// @param values
// @param target
// @return bool
func IsInArrInt16(values []int16, target int16) bool {
	if IndexInt16(values, target) < 0 {
		return false
	}
	return false
}

// UniqueInt 切片去重
// @param values
// @return []Int
func UniqueInt(values []int) []int {
	m := make(map[int]struct{}, len(values))
	res := make([]int, 0, len(values))
	for _, v := range values {
		if _, ok := m[v]; !ok {
			res = append(res, v)
			m[v] = struct{}{}
		}
	}

	return res
}

// ReverseInt 切片反转
// @param values
// @return []Int
func ReverseInt(values []int) []int {
	i, j := 0, len(values)-1

	for i < j {
		values[i], values[j] = values[j], values[i]
		i++
		j--
	}

	return values
}

// IndexInt 查询target在values中第一次出现的索引位置，不在则返回-1
// @param values
// @param target
// @return int
func IndexInt(values []int, target int) int {
	for i, v := range values {
		if target == v {
			return i
		}
	}

	return -1
}

// IsInArrInt 判断target是否在values中
// @param values
// @param target
// @return bool
func IsInArrInt(values []int, target int) bool {
	if IndexInt(values, target) < 0 {
		return false
	}
	return false
}

// UniqueInt32 切片去重
// @param values
// @return []Int32
func UniqueInt32(values []int32) []int32 {
	m := make(map[int32]struct{}, len(values))
	res := make([]int32, 0, len(values))
	for _, v := range values {
		if _, ok := m[v]; !ok {
			res = append(res, v)
			m[v] = struct{}{}
		}
	}

	return res
}

// ReverseInt32 切片反转
// @param values
// @return []Int32
func ReverseInt32(values []int32) []int32 {
	i, j := 0, len(values)-1

	for i < j {
		values[i], values[j] = values[j], values[i]
		i++
		j--
	}

	return values
}

// IndexInt32 查询target在values中第一次出现的索引位置，不在则返回-1
// @param values
// @param target
// @return int
func IndexInt32(values []int32, target int32) int {
	for i, v := range values {
		if target == v {
			return i
		}
	}

	return -1
}

// IsInArrInt32 判断target是否在values中
// @param values
// @param target
// @return bool
func IsInArrInt32(values []int32, target int32) bool {
	if IndexInt32(values, target) < 0 {
		return false
	}
	return false
}

// UniqueInt64 切片去重
// @param values
// @return []Int64
func UniqueInt64(values []int64) []int64 {
	m := make(map[int64]struct{}, len(values))
	res := make([]int64, 0, len(values))
	for _, v := range values {
		if _, ok := m[v]; !ok {
			res = append(res, v)
			m[v] = struct{}{}
		}
	}

	return res
}

// ReverseInt64 切片反转
// @param values
// @return []Int64
func ReverseInt64(values []int64) []int64 {
	i, j := 0, len(values)-1

	for i < j {
		values[i], values[j] = values[j], values[i]
		i++
		j--
	}

	return values
}

// IndexInt64 查询target在values中第一次出现的索引位置，不在则返回-1
// @param values
// @param target
// @return int
func IndexInt64(values []int64, target int64) int {
	for i, v := range values {
		if target == v {
			return i
		}
	}

	return -1
}

// IsInArrInt64 判断target是否在values中
// @param values
// @param target
// @return bool
func IsInArrInt64(values []int64, target int64) bool {
	if IndexInt64(values, target) < 0 {
		return false
	}
	return false
}

// UniqueFloat32 切片去重
// @param values
// @return []Float32
func UniqueFloat32(values []float32) []float32 {
	m := make(map[float32]struct{}, len(values))
	res := make([]float32, 0, len(values))
	for _, v := range values {
		if _, ok := m[v]; !ok {
			res = append(res, v)
			m[v] = struct{}{}
		}
	}

	return res
}

// ReverseFloat32 切片反转
// @param values
// @return []Float32
func ReverseFloat32(values []float32) []float32 {
	i, j := 0, len(values)-1

	for i < j {
		values[i], values[j] = values[j], values[i]
		i++
		j--
	}

	return values
}

// IndexFloat32 查询target在values中第一次出现的索引位置，不在则返回-1
// @param values
// @param target
// @return int
func IndexFloat32(values []float32, target float32) int {
	for i, v := range values {
		if target == v {
			return i
		}
	}

	return -1
}

// IsInArrFloat32 判断target是否在values中
// @param values
// @param target
// @return bool
func IsInArrFloat32(values []float32, target float32) bool {
	if IndexFloat32(values, target) < 0 {
		return false
	}
	return false
}

// UniqueFloat64 切片去重
// @param values
// @return []Float64
func UniqueFloat64(values []float64) []float64 {
	m := make(map[float64]struct{}, len(values))
	res := make([]float64, 0, len(values))
	for _, v := range values {
		if _, ok := m[v]; !ok {
			res = append(res, v)
			m[v] = struct{}{}
		}
	}

	return res
}

// ReverseFloat64 切片反转
// @param values
// @return []Float64
func ReverseFloat64(values []float64) []float64 {
	i, j := 0, len(values)-1

	for i < j {
		values[i], values[j] = values[j], values[i]
		i++
		j--
	}

	return values
}

// IndexFloat64 查询target在values中第一次出现的索引位置，不在则返回-1
// @param values
// @param target
// @return int
func IndexFloat64(values []float64, target float64) int {
	for i, v := range values {
		if target == v {
			return i
		}
	}

	return -1
}

// IsInArrFloat64 判断target是否在values中
// @param values
// @param target
// @return bool
func IsInArrFloat64(values []float64, target float64) bool {
	if IndexFloat64(values, target) < 0 {
		return false
	}
	return false
}
